"""
Data models for the AWS Lambda Architecture implementation.
These models define the structure of data flowing through the pipeline.
"""

from datetime import datetime
from typing import Optional, Dict, Any, List
from pydantic import BaseModel, Field
from decimal import Decimal


class TickData(BaseModel):
    """Raw tick data from Polygon.io WebSocket"""
    symbol: str
    price: Decimal = Field(..., description="Current price")
    volume: int = Field(..., description="Volume for this tick")
    timestamp: datetime = Field(..., description="Timestamp of the tick")
    exchange: Optional[str] = None
    conditions: Optional[List[int]] = None
    
    class Config:
        json_encoders = {
            Decimal: str,
            datetime: lambda v: v.isoformat()
        }


class OHLCVData(BaseModel):
    """OHLCV candlestick data"""
    symbol: str
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: int
    timestamp: datetime
    interval: str = Field(..., description="Interval (e.g., '1m', '5m', '1h', '1d')")
    
    class Config:
        json_encoders = {
            Decimal: str,
            datetime: lambda v: v.isoformat()
        }


class TechnicalIndicator(BaseModel):
    """Technical indicator value"""
    symbol: str
    indicator_type: str = Field(..., description="e.g., 'ema', 'rsi', 'macd'")
    value: Decimal
    timestamp: datetime
    interval: str
    parameters: Dict[str, Any] = Field(default_factory=dict)
    
    class Config:
        json_encoders = {
            Decimal: str,
            datetime: lambda v: v.isoformat()
        }


class TradingSignal(BaseModel):
    """Trading signal generated by strategy"""
    signal_id: str = Field(..., description="Unique signal identifier")
    symbol: str
    signal_type: str = Field(..., description="'BUY', 'SELL', 'HOLD'")
    strategy: str = Field(..., description="Strategy that generated the signal")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Confidence level 0-1")
    price: Decimal = Field(..., description="Price when signal was generated")
    timestamp: datetime
    metadata: Dict[str, Any] = Field(default_factory=dict)
    
    class Config:
        json_encoders = {
            Decimal: str,
            datetime: lambda v: v.isoformat()
        }


class MarketAlert(BaseModel):
    """Market alert/notification"""
    alert_id: str
    symbol: str
    alert_type: str = Field(..., description="'PRICE_BREAKOUT', 'VOLUME_SPIKE', etc.")
    message: str
    severity: str = Field(..., description="'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'")
    timestamp: datetime
    conditions: Dict[str, Any] = Field(default_factory=dict)
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }


class BatchProcessingJob(BaseModel):
    """Batch processing job metadata"""
    job_id: str
    job_type: str = Field(..., description="'DAILY_OHLCV', 'RESAMPLING', 'INDICATORS'")
    status: str = Field(..., description="'PENDING', 'RUNNING', 'COMPLETED', 'FAILED'")
    start_time: datetime
    end_time: Optional[datetime] = None
    symbols_processed: List[str] = Field(default_factory=list)
    records_processed: int = 0
    error_message: Optional[str] = None
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }


class StreamProcessingMetrics(BaseModel):
    """Metrics for stream processing"""
    stream_name: str
    records_per_second: float
    lag_seconds: float
    error_rate: float
    timestamp: datetime
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }


class APIResponse(BaseModel):
    """Standard API response format"""
    success: bool
    data: Optional[Any] = None
    error: Optional[str] = None
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    request_id: Optional[str] = None
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }


class LivePriceResponse(BaseModel):
    """Response for live price API"""
    symbol: str
    price: Decimal
    change: Optional[Decimal] = None
    change_percent: Optional[float] = None
    volume: Optional[int] = None
    timestamp: datetime
    source: str = Field(..., description="'CACHE', 'DATABASE', 'API'")
    
    class Config:
        json_encoders = {
            Decimal: str,
            datetime: lambda v: v.isoformat()
        }


class HistoricalDataResponse(BaseModel):
    """Response for historical data API"""
    symbol: str
    interval: str
    data: List[OHLCVData]
    count: int
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }


class SignalResponse(BaseModel):
    """Response for trading signals API"""
    symbol: str
    signals: List[TradingSignal]
    count: int
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }
